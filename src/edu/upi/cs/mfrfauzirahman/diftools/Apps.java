/**
 * Copyright 2018 Muhammad Fauzi Rahman
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @name Digital Image Forensic Tools.
 * @info Used for educational research about image forensics.
 * @hardware (CPU) Intel Core i7-4710HQ @ 2.50GHz, (RAM) 2x8 GB DDR3L 1600MHz
 * @java v1.8 (JDK 8) or v10 (JDK 10, may cause incorrect form layout)
 * @disclaimer 	This application MAY NOT giving an accurate results, 
 * 				even if this application using references from scientific research as close as possible.
 * @warning There is no optimization process and/or extended analysis regarding the application's process.
 * 			This application MAY NOT following the programming standards/best practices.
 * 			Expect it to run with (maybe very) heavy computing resources.
 * 			May cause unexpected bugs, error, and/or exception.
 * 			This application may takes up very heavy processing for the CPU (may use up to 100% with CPU listed for development).			
 * 			This application may takes up memory more than 4GB or 8GB (needs an additional argument) for 2MP+ (1600x1200) images.
 * 
 * 
 * @author Muhammad Fauzi Rahman
 * @research Image Forensics: Error Level Analysis, Metadata & Thumbnail Extraction, Image Masking
 * @department Computer Science
 * @institution (Bandung) Indonesia University of Education / Universitas Pendidikan Indonesia
 * 
 * @Input Standard image formats (JDK 8), most image format (JDK 10). Highly prioritizes JPEG-format for all image processsing methods.
 * @ImageProcessing All images is processed in their original sizes.
 * @ImageDisplays All images is resized when displayed by the apps, follows the aspect ratio of the original image.
 * @ELA Uses 95% comparator quality by default, configurable.
 * @ELA Uses 20 error scale by default, 1-100, configurable.
 * @Mask Mask the original image based on ELA result.
 * @Mask Uses magnitude threshold, by default uses average threshold from ELA image, configurable.
 * @Mask 3 masking color selection (Default: Cyan, Yellow, Magenta).
 * @Metadata Supports all metadata types included from metadata-extractor library.
 * @Thumbnail Supports only JPEG-format EXIF thumbnail metadata for extraction. 
 * @Thumbnail Displayed in two version, the original or scaled down and large or scaled up for comparison with original image.
 * @Output JPEG-format image for re-compressed, ELA result, masked image, and thumbnail.
 * @Output Tab-separated values file for metadata.
 * 
 * @includes Error Level Analysis and Image Difference Masking, from Robert Streetman's ELA Project code.
 * @notes Modified to follows the application's requirements.
 * @reference https://github.com/rstreet85/ELA
 * @includes Metadata-extractor library by Drew Noakes
 * @notes Modifies ExifReader class (com.drew.metadata.exif:ExifReader) to directly extract the JPEG-EXIF thumbnail metadata to disks.
 * @reference https://github.com/drewnoakes/metadata-extractor
 */	


/**
 * Java package and imports.
 * Auto-generated by Eclipse.
 */
package edu.upi.cs.mfrfauzirahman.diftools;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.NumberFormat;
import java.util.Iterator;
import java.util.Locale;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSlider;
import javax.swing.JTabbedPane;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;

import com.drew.imaging.ImageMetadataReader;
import com.drew.imaging.ImageProcessingException;
import com.drew.metadata.Directory;
import com.drew.metadata.Metadata;
import com.drew.metadata.Tag;
import com.drew.metadata.exif.ExifThumbnailDirectory;

import edu.upi.cs.mfrfauzirahman.diftools.utilities.ComboItem;
import edu.upi.cs.mfrfauzirahman.diftools.utilities.ImageELA;
import edu.upi.cs.mfrfauzirahman.diftools.utilities.ImageMask;
import edu.upi.cs.mfrfauzirahman.diftools.utilities.ImageTools;

/**
 * Apps class.
 * Main method and form of the application.
 */
public class Apps extends JFrame {
	
	/**
	 * File and path related field  
	 */
	private Boolean isOpening = false;
	private File inputfile = null;		
	private File outputfile = null;
	private String path = null;
	public static String imgFormat = null;
	
	/**
	 * Task-related field.
	 */
	private int taskType = 0;
	private Task taskEla;
	private Task taskMask;
	
	/**
	 * Application configurations field.
	 * Default values for all settings
	 */
	private static int[] MASK_RGB = ImageTools.MaskColor("CYAN");
	private static int errLevel = 20;
	private static int qualityLevel = 95;
	private static int maskThreshold = 25;
	
	/**
	 * Image processing and metadata-related field
	 */
	public Image img = null;
	public Metadata metadata = null;
	private BufferedImage imgInput = null;
    private BufferedImage imgRecomp = null;
    private BufferedImage imgELA = null;
    private BufferedImage imgMask = null;
    private BufferedImage imgThumb = null;
	private ImageIcon imgIco = null;
	
	/**
	 * Thumbnail related field
	 */
	private boolean thumbExists = false;
	private int thumbLen = 0;
	public int thumbWidth = 0;
	public int thumbHeight = 0;
	
	/**
	 * Image size-related field
	 */
	private int oriWidth = 0;
	private int scaleWidth = 0;
	private final int labWidth = 1005;
	private int oriHeight = 0;
	private int scaleHeight = 0;
	private final int labHeight = 642;
	
	/**
	 * Number formatting for file size
	 */
	public static final long KILO_BYTES = 1024;
	public static final long MEGA_BYTES = 1024 * KILO_BYTES;
    
    
    /**
     * Creates new form Apps
     */
    public Apps() {
    	setResizable(false);
    	addWindowListener(new WindowAdapter() {
    		@Override
    		public void windowClosing(WindowEvent e) {
    			clearTemp();
    		}
    	});
    	setPreferredSize(new Dimension(1280, 720));
        initComponents();
        setIconImage(Toolkit.getDefaultToolkit().getImage(Apps.class.getResource("/resources/ico.png")));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
    	labValQ = new JLabel();
    	labValQ.setBounds(114, 17, 50, 14);
    	labValQ.setText("95%");
        TabPanel = new javax.swing.JTabbedPane();
        TabPanel.setBounds(0, 0, 1010, 670);
        labInput = new javax.swing.JLabel();
        labInput.setHorizontalAlignment(SwingConstants.CENTER);
        TabConfig = new javax.swing.JTabbedPane();
        TabConfig.setBounds(1016, 470, 255, 200);
        pConfELA = new javax.swing.JPanel();
        labQuality = new javax.swing.JLabel();
        labQuality.setBounds(10, 11, 94, 22);
        sliderQuality = new javax.swing.JSlider();
        sliderQuality.setBounds(10, 44, 230, 22);
        sliderQuality.setMinimum(1);
        sliderQuality.addChangeListener(new ChangeListener() {
        	@Override
			public void stateChanged(ChangeEvent e) {
        		updQVal();
        	}
        });
        MenuBar = new javax.swing.JMenuBar();
        menuFile = new javax.swing.JMenu();
        mOpen = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Digital Image Forensics Tools");
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setIconImages(null);
        setMinimumSize(new java.awt.Dimension(1024, 720));
        setName("frameMain");
        setSize(new java.awt.Dimension(1280, 720));

        TabPanel.addTab("Input", labInput);
        labELA = new javax.swing.JLabel();
        labELA.setHorizontalAlignment(SwingConstants.CENTER);
        TabPanel.addTab("Error Level Analysis", labELA);
        
        labComp = new JLabel("");
        labComp.setHorizontalAlignment(SwingConstants.CENTER);
        TabPanel.addTab("Re-compressed", null, labComp, null);
        labMask = new javax.swing.JLabel();
        labMask.setHorizontalAlignment(SwingConstants.CENTER);
        TabPanel.addTab("Masked Image", labMask);
        
        labThumbBig = new JLabel();
        labThumbBig.setHorizontalTextPosition(SwingConstants.CENTER);
        labThumbBig.setHorizontalAlignment(SwingConstants.CENTER);
        TabPanel.addTab("Thumbnail (Large)", null, labThumbBig, null);

        labQuality.setFont(new Font("Tahoma", Font.PLAIN, 14)); // NOI18N
        labQuality.setText("JPEG Quality");

        sliderQuality.setValue(95);
        
        btnConfEla = new JButton("Apply");
        btnConfEla.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		try {
					applyConfigELA();
				} catch (ImageProcessingException e1) {
					e1.printStackTrace();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
        	}
        });
        btnConfEla.setBounds(10, 135, 59, 23);
        
        btnDefEla = new JButton("Default");
        btnDefEla.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		defConfigELA();
        	}
        });
        btnDefEla.setBounds(173, 135, 67, 23);

        TabConfig.addTab("Config (ELA)", pConfELA);
        
        labErrScale = new JLabel();
        labErrScale.setBounds(10, 69, 94, 22);
        labErrScale.setText("Error Scale");
        labErrScale.setFont(new Font("Tahoma", Font.PLAIN, 14));
        
        sliderErrScale = new JSlider();
        sliderErrScale.setMinimum(1);
        sliderErrScale.setValue(20);
        sliderErrScale.addChangeListener(new ChangeListener() {
        	public void stateChanged(ChangeEvent e) {
        		updErrVal();
        	}
        });
        sliderErrScale.setBounds(10, 102, 230, 22);
        pConfELA.setLayout(null);
        pConfELA.add(labQuality);
        pConfELA.add(labValQ);
        pConfELA.add(sliderErrScale);
        pConfELA.add(sliderQuality);
        pConfELA.add(labErrScale);
        pConfELA.add(btnConfEla);
        pConfELA.add(btnDefEla);
        
        labValE = new JLabel();
        labValE.setText("20");
        labValE.setBounds(114, 77, 50, 14);
        pConfELA.add(labValE);

        menuFile.setText("File");

        mOpen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        mOpen.setText("Open Image");
        mOpen.setToolTipText("");
        mOpen.addActionListener(new java.awt.event.ActionListener() {
            @Override
			public void actionPerformed(java.awt.event.ActionEvent evt) {
                try {
					mOpenIMG();
				} catch (IOException e) {
					e.printStackTrace();
				}
            }
        });
        menuFile.add(mOpen);

        MenuBar.add(menuFile);
        
        mntmSaveRecomp = new JMenuItem("Save Recompressed Image");
        mntmSaveRecomp.setEnabled(false);
        mntmSaveRecomp.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		try {
					mSaveRecompIMG();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
        	}
        });
        
        separator = new JSeparator();
        menuFile.add(separator);
        menuFile.add(mntmSaveRecomp);
        
        mntmSaveEla = new JMenuItem("Save ELA Result");
        mntmSaveEla.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		mSaveElaIMG();
        	}
        });
        mntmSaveEla.setEnabled(false);
        menuFile.add(mntmSaveEla);
        
        mntmSaveMaskedImage = new JMenuItem("Save Masked Image");
        mntmSaveMaskedImage.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		mSaveMaskedIMG();
        	}
        });
        mntmSaveMaskedImage.setEnabled(false);
        menuFile.add(mntmSaveMaskedImage);
        
        mntmSaveThumbnail = new JMenuItem("Save Thumbnail Image");
        mntmSaveThumbnail.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		mSaveThumbIMG();
        	}
        });
        mntmSaveThumbnail.setEnabled(false);
        menuFile.add(mntmSaveThumbnail);
        
        mntmSaveMetadata = new JMenuItem("Save Metadata");
        mntmSaveMetadata.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		mSaveMetadata();
        	}
        });
        mntmSaveMetadata.setEnabled(false);
        menuFile.add(mntmSaveMetadata);

        setJMenuBar(MenuBar);
        
        JTabbedPane TabAnalysis = new JTabbedPane(SwingConstants.TOP);
        TabAnalysis.setBounds(1016, 0, 255, 245);
        
        TabThumb = new JTabbedPane(JTabbedPane.TOP);
        TabThumb.setBounds(1016, 297, 255, 167);
        
        labThumbSmall = new JLabel("");
        labThumbSmall.setHorizontalAlignment(SwingConstants.CENTER);
        TabThumb.addTab("Thumbnail (Small)", null, labThumbSmall, null);
        
        pConfMask = new JPanel();
        pConfMask.setLayout(null);
        TabConfig.addTab("Config (Mask)", null, pConfMask, null);
        
        labMaskThresh = new JLabel();
        labMaskThresh.setText("Mask Threshold");
        labMaskThresh.setFont(new Font("Tahoma", Font.PLAIN, 14));
        labMaskThresh.setBounds(10, 11, 94, 22);
        pConfMask.add(labMaskThresh);
        
        labValT = new JLabel();
        labValT.setText("25");
        labValT.setBounds(114, 17, 126, 14);
        pConfMask.add(labValT);
        
        sliderThresh = new JSlider();
        sliderThresh.addChangeListener(new ChangeListener() {
        	public void stateChanged(ChangeEvent e) {
        		updTVal();
        	}
        });
        sliderThresh.setMaximum(765);
        sliderThresh.setValue(25);
        sliderThresh.setMinimum(1);
        sliderThresh.setBounds(10, 44, 230, 22);
        pConfMask.add(sliderThresh);
        
        lblMaskColor = new JLabel();
        lblMaskColor.setText("Mask Color");
        lblMaskColor.setFont(new Font("Tahoma", Font.PLAIN, 14));
        lblMaskColor.setBounds(10, 69, 94, 22);
        pConfMask.add(lblMaskColor);
        
        btnConfMask = new JButton("Apply");
        btnConfMask.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		applyMask();
        	}
        });
        btnConfMask.setBounds(10, 133, 59, 23);
        pConfMask.add(btnConfMask);
        
        btnDefMask = new JButton("Default");
        btnDefMask.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		defMask();
        	}
        });
        btnDefMask.setBounds(173, 133, 67, 23);
        pConfMask.add(btnDefMask);
        
        comboMaskCol = new JComboBox<ComboItem>();
        comboMaskCol.addItemListener(new ItemListener() {
        	public void itemStateChanged(ItemEvent e) {
        		maskColorChange();
        	}
        });
        comboMaskCol.setBounds(10, 102, 230, 20);
        comboMaskCol.addItem(new ComboItem("Cyan", ImageTools.MaskColor("CYAN")));
        comboMaskCol.addItem(new ComboItem("Magenta", ImageTools.MaskColor("MAGENTA")));
        comboMaskCol.addItem(new ComboItem("Yellow", ImageTools.MaskColor("YELLOW")));
        comboMaskCol.setSelectedIndex(0);
        pConfMask.add(comboMaskCol);
        
        JPanel pDetails = new JPanel();
        TabAnalysis.addTab("Details", null, pDetails, null);
        
        lblFileSize = new JLabel("File size");
        lblFileSize.setBounds(10, 31, 37, 14);
        
        lblResolution = new JLabel("Resolution");
        lblResolution.setBounds(10, 52, 50, 14);
        
        lblPath = new JLabel("Path");
        lblPath.setBounds(10, 121, 22, 14);
        
        labResoVal = new JLabel("-");
        labResoVal.setBounds(66, 52, 174, 14);
        
        labFileSizeVal = new JLabel("-");
        labFileSizeVal.setBounds(66, 31, 174, 15);
        
        labFileNameVal = new JLabel("-");
        labFileNameVal.setBounds(66, 11, 174, 14);
        
        txtaPath = new JTextArea();
        txtaPath.setWrapStyleWord(true);
        txtaPath.setFont(UIManager.getFont("Label.font"));
        txtaPath.setLineWrap(true);
        txtaPath.setEditable(false);
        txtaPath.setBackground(UIManager.getColor("Button.background"));
        txtaPath.setBounds(66, 119, 174, 85);
        
        labFile = new JLabel("File name");
        labFile.setBounds(10, 11, 45, 14);
        pDetails.setLayout(null);
        pDetails.add(lblResolution);
        pDetails.add(lblFileSize);
        pDetails.add(lblPath);
        pDetails.add(labResoVal);
        pDetails.add(labFileNameVal);
        pDetails.add(labFileSizeVal);
        pDetails.add(txtaPath);
        pDetails.add(labFile);
        
        lblThumbnail = new JLabel("Thumbnail");
        lblThumbnail.setBounds(10, 73, 50, 14);
        pDetails.add(lblThumbnail);
        
        labThumbStatus = new JLabel("-");
        labThumbStatus.setBounds(66, 73, 78, 14);
        pDetails.add(labThumbStatus);
        
        lblThumbSize = new JLabel("Th. Size");
        lblThumbSize.setBounds(10, 94, 50, 14);
        pDetails.add(lblThumbSize);
        
        labThumbBytes = new JLabel("-");
        labThumbBytes.setBounds(66, 94, 174, 14);
        pDetails.add(labThumbBytes);
        
        pStatisticsInput = new JPanel();
        TabAnalysis.addTab("Input", null, pStatisticsInput, null);
        
        lblMinChannel = new JLabel("Min - Max Channel (Red)");
        lblMinChannel.setBounds(10, 11, 146, 14);
        pStatisticsInput.setLayout(null);
        pStatisticsInput.add(lblMinChannel);
        
        labInMinR = new JLabel("0");
        labInMinR.setHorizontalAlignment(SwingConstants.CENTER);
        labInMinR.setBounds(166, 11, 18, 14);
        pStatisticsInput.add(labInMinR);
        
        labInMaxR = new JLabel("0");
        labInMaxR.setHorizontalAlignment(SwingConstants.CENTER);
        labInMaxR.setBounds(222, 11, 18, 14);
        pStatisticsInput.add(labInMaxR);
        
        lblMaxChannel = new JLabel("Min - Max Channel (Green)");
        lblMaxChannel.setBounds(10, 36, 146, 14);
        pStatisticsInput.add(lblMaxChannel);
        
        lblMinMagnitude = new JLabel("Min - Max Channel (Blue)");
        lblMinMagnitude.setBounds(10, 61, 146, 14);
        pStatisticsInput.add(lblMinMagnitude);
        
        labInMinB = new JLabel("0");
        labInMinB.setHorizontalAlignment(SwingConstants.CENTER);
        labInMinB.setBounds(166, 61, 18, 14);
        pStatisticsInput.add(labInMinB);
        
        labInAvgMag = new JLabel("0");
        labInAvgMag.setHorizontalAlignment(SwingConstants.CENTER);
        labInAvgMag.setBounds(166, 161, 74, 14);
        pStatisticsInput.add(labInAvgMag);
        
        label_15 = new JLabel("-");
        label_15.setHorizontalAlignment(SwingConstants.CENTER);
        label_15.setBounds(194, 61, 18, 14);
        pStatisticsInput.add(label_15);
        
        label_1 = new JLabel("Min - Max Magnitude");
        label_1.setBounds(10, 86, 146, 14);
        pStatisticsInput.add(label_1);
        
        labInMinMag = new JLabel("0");
        labInMinMag.setHorizontalAlignment(SwingConstants.CENTER);
        labInMinMag.setBounds(166, 86, 18, 14);
        pStatisticsInput.add(labInMinMag);
        
        label_11 = new JLabel("-");
        label_11.setHorizontalAlignment(SwingConstants.CENTER);
        label_11.setBounds(194, 86, 18, 14);
        pStatisticsInput.add(label_11);
        
        labInMaxMag = new JLabel("0");
        labInMaxMag.setHorizontalAlignment(SwingConstants.CENTER);
        labInMaxMag.setBounds(222, 86, 18, 14);
        pStatisticsInput.add(labInMaxMag);
        
        label = new JLabel("-");
        label.setHorizontalAlignment(SwingConstants.CENTER);
        label.setBounds(194, 11, 18, 14);
        pStatisticsInput.add(label);
        
        label_20 = new JLabel("-");
        label_20.setHorizontalAlignment(SwingConstants.CENTER);
        label_20.setBounds(194, 36, 18, 14);
        pStatisticsInput.add(label_20);
        
        labIn = new JLabel("Average Magnitude");
        labIn.setBounds(10, 161, 146, 14);
        pStatisticsInput.add(labIn);
        
        labInMaxG = new JLabel("0");
        labInMaxG.setHorizontalAlignment(SwingConstants.CENTER);
        labInMaxG.setBounds(222, 36, 18, 14);
        pStatisticsInput.add(labInMaxG);
        
        labInMaxB = new JLabel("0");
        labInMaxB.setHorizontalAlignment(SwingConstants.CENTER);
        labInMaxB.setBounds(222, 61, 18, 14);
        pStatisticsInput.add(labInMaxB);
        
        labInMinG = new JLabel("0");
        labInMinG.setHorizontalAlignment(SwingConstants.CENTER);
        labInMinG.setBounds(166, 36, 18, 14);
        pStatisticsInput.add(labInMinG);
        
        lblAverageValue = new JLabel("Average Value (R, G, B)");
        lblAverageValue.setBounds(10, 111, 230, 14);
        pStatisticsInput.add(lblAverageValue);
        
        labInAvgR = new JLabel("0");
        labInAvgR.setHorizontalAlignment(SwingConstants.CENTER);
        labInAvgR.setBounds(10, 136, 70, 14);
        pStatisticsInput.add(labInAvgR);
        
        labInAvgG = new JLabel("0");
        labInAvgG.setHorizontalAlignment(SwingConstants.CENTER);
        labInAvgG.setBounds(90, 136, 70, 14);
        pStatisticsInput.add(labInAvgG);
        
        labInAvgB = new JLabel("0");
        labInAvgB.setHorizontalAlignment(SwingConstants.CENTER);
        labInAvgB.setBounds(170, 136, 70, 14);
        pStatisticsInput.add(labInAvgB);
        
        panel = new JPanel();
        panel.setLayout(null);
        TabAnalysis.addTab("Recompressed", null, panel, null);
        
        label_2 = new JLabel("Min - Max Channel (Red)");
        label_2.setBounds(10, 11, 146, 14);
        panel.add(label_2);
        
        labRecMinR = new JLabel("0");
        labRecMinR.setHorizontalAlignment(SwingConstants.CENTER);
        labRecMinR.setBounds(166, 11, 18, 14);
        panel.add(labRecMinR);
        
        labRecMaxR = new JLabel("0");
        labRecMaxR.setHorizontalAlignment(SwingConstants.CENTER);
        labRecMaxR.setBounds(222, 11, 18, 14);
        panel.add(labRecMaxR);
        
        label_5 = new JLabel("Min - Max Channel (Green)");
        label_5.setBounds(10, 36, 146, 14);
        panel.add(label_5);
        
        label_6 = new JLabel("Min - Max Channel (Blue)");
        label_6.setBounds(10, 61, 146, 14);
        panel.add(label_6);
        
        labRecMinB = new JLabel("0");
        labRecMinB.setHorizontalAlignment(SwingConstants.CENTER);
        labRecMinB.setBounds(166, 61, 18, 14);
        panel.add(labRecMinB);
        
        labRecAvgMag = new JLabel("0");
        labRecAvgMag.setHorizontalAlignment(SwingConstants.CENTER);
        labRecAvgMag.setBounds(166, 161, 74, 14);
        panel.add(labRecAvgMag);
        
        label_9 = new JLabel("-");
        label_9.setHorizontalAlignment(SwingConstants.CENTER);
        label_9.setBounds(194, 61, 18, 14);
        panel.add(label_9);
        
        label_10 = new JLabel("Min - Max Magnitude");
        label_10.setBounds(10, 86, 146, 14);
        panel.add(label_10);
        
        labRecMinMag = new JLabel("0");
        labRecMinMag.setHorizontalAlignment(SwingConstants.CENTER);
        labRecMinMag.setBounds(166, 86, 18, 14);
        panel.add(labRecMinMag);
        
        label_13 = new JLabel("-");
        label_13.setHorizontalAlignment(SwingConstants.CENTER);
        label_13.setBounds(194, 86, 18, 14);
        panel.add(label_13);
        
        labRecMaxMag = new JLabel("0");
        labRecMaxMag.setHorizontalAlignment(SwingConstants.CENTER);
        labRecMaxMag.setBounds(222, 86, 18, 14);
        panel.add(labRecMaxMag);
        
        label_16 = new JLabel("-");
        label_16.setHorizontalAlignment(SwingConstants.CENTER);
        label_16.setBounds(194, 11, 18, 14);
        panel.add(label_16);
        
        label_17 = new JLabel("-");
        label_17.setHorizontalAlignment(SwingConstants.CENTER);
        label_17.setBounds(194, 36, 18, 14);
        panel.add(label_17);
        
        label_18 = new JLabel("Average Magnitude");
        label_18.setBounds(10, 161, 146, 14);
        panel.add(label_18);
        
        labRecMaxG = new JLabel("0");
        labRecMaxG.setHorizontalAlignment(SwingConstants.CENTER);
        labRecMaxG.setBounds(222, 36, 18, 14);
        panel.add(labRecMaxG);
        
        labRecMaxB = new JLabel("0");
        labRecMaxB.setHorizontalAlignment(SwingConstants.CENTER);
        labRecMaxB.setBounds(222, 61, 18, 14);
        panel.add(labRecMaxB);
        
        labRecMinG = new JLabel("0");
        labRecMinG.setHorizontalAlignment(SwingConstants.CENTER);
        labRecMinG.setBounds(166, 36, 18, 14);
        panel.add(labRecMinG);
        
        label_23 = new JLabel("Average Value (R, G, B)");
        label_23.setBounds(10, 111, 230, 14);
        panel.add(label_23);
        
        labRecAvgR = new JLabel("0");
        labRecAvgR.setHorizontalAlignment(SwingConstants.CENTER);
        labRecAvgR.setBounds(10, 136, 70, 14);
        panel.add(labRecAvgR);
        
        labRecAvgG = new JLabel("0");
        labRecAvgG.setHorizontalAlignment(SwingConstants.CENTER);
        labRecAvgG.setBounds(90, 136, 70, 14);
        panel.add(labRecAvgG);
        
        labRecAvgB = new JLabel("0");
        labRecAvgB.setHorizontalAlignment(SwingConstants.CENTER);
        labRecAvgB.setBounds(170, 136, 70, 14);
        panel.add(labRecAvgB);
        
        pStatisticsELA = new JPanel();
        pStatisticsELA.setLayout(null);
        TabAnalysis.addTab("Statistics (ELA)", null, pStatisticsELA, null);
        
        label_27 = new JLabel("Min - Max Channel (Red)");
        label_27.setBounds(10, 11, 146, 14);
        pStatisticsELA.add(label_27);
        
        labElaMinR = new JLabel("0");
        labElaMinR.setHorizontalAlignment(SwingConstants.CENTER);
        labElaMinR.setBounds(166, 11, 18, 14);
        pStatisticsELA.add(labElaMinR);
        
        labElaMaxR = new JLabel("0");
        labElaMaxR.setHorizontalAlignment(SwingConstants.CENTER);
        labElaMaxR.setBounds(222, 11, 18, 14);
        pStatisticsELA.add(labElaMaxR);
        
        label_30 = new JLabel("Min - Max Channel (Green)");
        label_30.setBounds(10, 36, 146, 14);
        pStatisticsELA.add(label_30);
        
        label_31 = new JLabel("Min - Max Channel (Blue)");
        label_31.setBounds(10, 61, 146, 14);
        pStatisticsELA.add(label_31);
        
        labElaMinB = new JLabel("0");
        labElaMinB.setHorizontalAlignment(SwingConstants.CENTER);
        labElaMinB.setBounds(166, 61, 18, 14);
        pStatisticsELA.add(labElaMinB);
        
        labElaAvgMag = new JLabel("0");
        labElaAvgMag.setHorizontalAlignment(SwingConstants.CENTER);
        labElaAvgMag.setBounds(166, 161, 74, 14);
        pStatisticsELA.add(labElaAvgMag);
        
        label_34 = new JLabel("-");
        label_34.setHorizontalAlignment(SwingConstants.CENTER);
        label_34.setBounds(194, 61, 18, 14);
        pStatisticsELA.add(label_34);
        
        label_35 = new JLabel("Min - Max Magnitude");
        label_35.setBounds(10, 86, 146, 14);
        pStatisticsELA.add(label_35);
        
        labElaMinMag = new JLabel("0");
        labElaMinMag.setHorizontalAlignment(SwingConstants.CENTER);
        labElaMinMag.setBounds(166, 86, 18, 14);
        pStatisticsELA.add(labElaMinMag);
        
        label_37 = new JLabel("-");
        label_37.setHorizontalAlignment(SwingConstants.CENTER);
        label_37.setBounds(194, 86, 18, 14);
        pStatisticsELA.add(label_37);
        
        labElaMaxMag = new JLabel("0");
        labElaMaxMag.setHorizontalAlignment(SwingConstants.CENTER);
        labElaMaxMag.setBounds(222, 86, 18, 14);
        pStatisticsELA.add(labElaMaxMag);
        
        label_39 = new JLabel("-");
        label_39.setHorizontalAlignment(SwingConstants.CENTER);
        label_39.setBounds(194, 11, 18, 14);
        pStatisticsELA.add(label_39);
        
        label_40 = new JLabel("-");
        label_40.setHorizontalAlignment(SwingConstants.CENTER);
        label_40.setBounds(194, 36, 18, 14);
        pStatisticsELA.add(label_40);
        
        label_41 = new JLabel("Average Magnitude");
        label_41.setBounds(10, 161, 146, 14);
        pStatisticsELA.add(label_41);
        
        labElaMaxG = new JLabel("0");
        labElaMaxG.setHorizontalAlignment(SwingConstants.CENTER);
        labElaMaxG.setBounds(222, 36, 18, 14);
        pStatisticsELA.add(labElaMaxG);
        
        labElaMaxB = new JLabel("0");
        labElaMaxB.setHorizontalAlignment(SwingConstants.CENTER);
        labElaMaxB.setBounds(222, 61, 18, 14);
        pStatisticsELA.add(labElaMaxB);
        
        labElaMinG = new JLabel("0");
        labElaMinG.setHorizontalAlignment(SwingConstants.CENTER);
        labElaMinG.setBounds(166, 36, 18, 14);
        pStatisticsELA.add(labElaMinG);
        
        label_45 = new JLabel("Average Value (R, G, B)");
        label_45.setBounds(10, 111, 146, 14);
        pStatisticsELA.add(label_45);
        
        labElaAvgR = new JLabel("0");
        labElaAvgR.setHorizontalAlignment(SwingConstants.CENTER);
        labElaAvgR.setHorizontalTextPosition(SwingConstants.CENTER);
        labElaAvgR.setBounds(10, 136, 70, 14);
        pStatisticsELA.add(labElaAvgR);
        
        labElaAvgB = new JLabel("0");
        labElaAvgB.setHorizontalAlignment(SwingConstants.CENTER);
        labElaAvgB.setHorizontalTextPosition(SwingConstants.CENTER);
        labElaAvgB.setBounds(170, 136, 70, 14);
        pStatisticsELA.add(labElaAvgB);
        
        labElaAvgG = new JLabel("0");
        labElaAvgG.setHorizontalTextPosition(SwingConstants.CENTER);
        labElaAvgG.setHorizontalAlignment(SwingConstants.CENTER);
        labElaAvgG.setBounds(90, 136, 70, 14);
        pStatisticsELA.add(labElaAvgG);
        
        spMetadata = new JScrollPane();
        spMetadata.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        TabPanel.addTab("Metadata Table", null, spMetadata, null);
        
        tMetadata = new JTable(new DefaultTableModel(
        	new Object[][] {
        		{null, null, null},
        	},
        	new String[] {
        		"Directory", "Tag Name", "Value"
        	}
          ) {
        	@Override
            public boolean isCellEditable(int row, int column) {
               return false;
            }
        });
        
        tMetadata.getColumnModel().getColumn(0).setPreferredWidth(75);
        tMetadata.getColumnModel().getColumn(0).setMaxWidth(100);
        tMetadata.getColumnModel().getColumn(1).setPreferredWidth(100);
        tMetadata.getColumnModel().getColumn(1).setMaxWidth(200);
        tMetadata.getColumnModel().getColumn(1).setMinWidth(200);
        getContentPane().setLayout(null);
        
        spMetadata.setViewportView(tMetadata);
        getContentPane().add(TabPanel);
        getContentPane().add(TabThumb);
        getContentPane().add(TabConfig);
        getContentPane().add(TabAnalysis);
        
        loadingBar = new JProgressBar();
        loadingBar.setBounds(1020, 256, 244, 30);
        loadingBar.setStringPainted(true);
        getContentPane().add(loadingBar);
        
        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Windows look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Windows (introduced in Java SE 6) is not available, s	tay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            	if ("Windows".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
            //javax.swing.UIManager.setLookAndFeel( javax.swing.UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Apps.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Apps.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Apps.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Apps.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
			public void run() {
                new Apps().setVisible(true);
                loadingBar.setString("Waiting");
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private JMenuBar MenuBar;
    private JMenu menuFile;
    private JMenuItem mOpen;
    private JMenuItem mntmSaveRecomp;
    private JMenuItem mntmSaveMetadata;
    private JMenuItem mntmSaveEla;
    private JMenuItem mntmSaveMaskedImage;
    private JMenuItem mntmSaveThumbnail;
    private JTabbedPane TabThumb;
    private JTabbedPane TabConfig;
    private JTabbedPane TabPanel;
    private JScrollPane spMetadata;
    private JTable tMetadata;
    private JButton btnConfMask;
    private JButton btnDefMask;
    private JButton btnConfEla;
    private JButton btnDefEla;
    private JTextArea txtaPath;
    private JSlider sliderThresh;
    private JSlider sliderErrScale;
    private JSlider sliderQuality;
    private JPanel pConfMask;
    private JPanel pStatisticsInput;
    private JPanel pStatisticsELA;
    private JPanel panel;
    private JPanel pConfELA;
    private JLabel labValQ;
    private JLabel labComp;
    private JLabel labErrScale;
    private JLabel lblFileSize;
    private JLabel lblResolution;
    private JLabel lblPath;
    private JLabel labResoVal;
    private JLabel labFileSizeVal;
    private JLabel labFileNameVal;
    private JLabel labThumbBig;
    private JLabel labFile;
    private JLabel labValE;
    private JLabel labMaskThresh;
    private JLabel labValT;
    private JLabel lblMaskColor;
    private JLabel lblAverageValue;
    private JLabel labELA;
    private JLabel labInput;
    private JLabel labMask;
    private JLabel labQuality;
    private JLabel labThumbSmall;
    private JLabel lblThumbnail;
    private JLabel labThumbStatus;
    private JLabel lblThumbSize;
    private JLabel labThumbBytes;
    private JLabel lblMinChannel;
    private JLabel lblMaxChannel;
    private JLabel lblMinMagnitude;
    private JLabel labIn;
    private JComboBox<ComboItem> comboMaskCol;
    private JSeparator separator;
    private JLabel label_11;
    private JLabel label_15;
    private JLabel label_1;
    private JLabel label;
    private JLabel label_20;
    private JLabel label_2;
    private JLabel label_5;
    private JLabel label_6;
    private JLabel label_9;
    private JLabel label_10;
    private JLabel label_13;
    private JLabel label_16;
    private JLabel label_17;
    private JLabel label_18;
    private JLabel label_23;
    private JLabel label_27;
    private JLabel label_30;
    private JLabel label_31;
    private JLabel label_34;
    private JLabel label_35;
    private JLabel label_37;
    private JLabel label_39;
    private JLabel label_40;
    private JLabel label_41;
    private JLabel label_45; 
    private static JLabel labInMinR;
    private static JLabel labInMaxR;
    private static JLabel labInMinB;
    private static JLabel labInAvgMag;
    private static JLabel labInMinMag;
    private static JLabel labInMaxMag;
    private static JLabel labInAvgR;
    private static JLabel labInAvgG;
    private static JLabel labInAvgB;   
    private static JLabel labInMaxG;
    private static JLabel labInMaxB;
    private static JLabel labInMinG;
    private static JLabel labRecMinR;
    private static JLabel labRecMaxR;    
    private static JLabel labRecMinB;
    private static JLabel labRecAvgMag;    
    private static JLabel labRecMinMag;   
    private static JLabel labRecMaxMag;   
    private static JLabel labRecMaxG;
    private static JLabel labRecMaxB;
    private static JLabel labRecMinG;    
    private static JLabel labRecAvgR;
    private static JLabel labRecAvgG;
    private static JLabel labRecAvgB;
    private static JLabel labElaMinR;
    private static JLabel labElaMaxR;    
    private static JLabel labElaMinB;
    private static JLabel labElaAvgMag;    
    private static JLabel labElaMinMag;    
    private static JLabel labElaMaxMag;    
    private static JLabel labElaMaxG;
    private static JLabel labElaMaxB;
    private static JLabel labElaMinG;
    private static JLabel labElaAvgR;
    private static JLabel labElaAvgB;
    private static JLabel labElaAvgG;    
    private static JProgressBar loadingBar;
    
    
    /**
     * Method for opening an image.
     * Opens an image.
     * Clear the data folder.
     * Applies ELA.
     * Write Metadata table.
     * Check and set Thumbnail from metadata (if exists).
     * Display file info.
     *
     * @throws IOException
     */
    void mOpenIMG() throws IOException {
        final JFileChooser fc = new JFileChooser();
        if(path != null) {
        	fc.setCurrentDirectory(new File(path));
        }
        
        fc.setFileFilter(new FileNameExtensionFilter("Image files", ImageIO.getReaderFileSuffixes()));
        int result = fc.showOpenDialog(MenuBar);
        if (result == JFileChooser.APPROVE_OPTION) {
        	mntmSaveRecomp.setEnabled(false);
        	mntmSaveEla.setEnabled(false);
        	mntmSaveMaskedImage.setEnabled(false);
        	mntmSaveMetadata.setEnabled(false);
        	mntmSaveThumbnail.setEnabled(false);
        	
        	clearTemp();
        	
            inputfile = fc.getSelectedFile();
            path = inputfile.getAbsolutePath();
            imgFormat = FilenameUtils.getExtension(inputfile.getName());
            
            try {
                imgInput = ImageIO.read(inputfile);
                isOpening = true;
                applyConfigELA();                
            } catch (IOException | ImageProcessingException ex) {
                Logger.getLogger(Apps.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            try {
            	DefaultTableModel tablemodel = null;
            	metadata = ImageMetadataReader.readMetadata(inputfile);
                writeTable(metadata, tMetadata, tablemodel);
            } catch (IOException | ImageProcessingException ex) {
                Logger.getLogger(Apps.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            chkThumb();
            setThumb();
            if(thumbExists == true) {
            	labThumbStatus.setText("Available");
            	labThumbBytes.setText(thumbLen + " bytes");
            	mntmSaveThumbnail.setEnabled(true);
            }else {
            	labThumbStatus.setText("Not Available");
            	labThumbBytes.setText("-");
            	mntmSaveThumbnail.setEnabled(false);
            }
            txtaPath.setText(inputfile.getPath());
            labFileNameVal.setText(inputfile.getName());
            labFileSizeVal.setText(formatSize(inputfile.length()));
            labResoVal.setText(imgInput.getWidth() + " x " + imgInput.getHeight());
            
            callGC();
        }
    }
    
    /**
     * Method to save the re-compressed image.
     * Copies the re-compressed image from 'data' folder to the selected path.
     * 
     * @throws IOException
     * @output JPEG-format image
     */
    void mSaveRecompIMG() throws IOException {
    	final JFileChooser fc = new JFileChooser();
        fc.setFileFilter(new FileNameExtensionFilter("JPG Image (JPG)", "jpg"));
        if(path != null) {
        	fc.setCurrentDirectory(new File(path));
        }
        fc.setSelectedFile(new File(FilenameUtils.removeExtension(inputfile.getName())+"_recompressed"));
        int result = fc.showSaveDialog(MenuBar);
        if (result == JFileChooser.APPROVE_OPTION) {  	
        	try {
				FileUtils.copyFile(new File("data/recompressed.jpg"), new File(fc.getSelectedFile()+".jpg"));
			} catch (IOException e) {
				e.printStackTrace();
				JOptionPane.showMessageDialog(null, "Unexpected error occured when trying to save recompressed image. \n"
						+e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
			}
        }
    }
    
    /**
     * Method to save ELA result image.
     * Copies the ELA image from 'data' folder to the selected path.
     * 
     * @output JPEG-format image
     */
    void mSaveElaIMG() {
    	final JFileChooser fc = new JFileChooser();
        fc.setFileFilter(new FileNameExtensionFilter("JPG Image (JPG)", "jpg"));
        if(path != null) {
        	fc.setCurrentDirectory(new File(path));
        }
        fc.setSelectedFile(new File(FilenameUtils.removeExtension(inputfile.getName())+"_ELA"));
        int result = fc.showSaveDialog(MenuBar);
        if (result == JFileChooser.APPROVE_OPTION) {
        	try {
				FileUtils.copyFile(new File("data/ELA.jpg"), new File(fc.getSelectedFile()+".jpg"));
			} catch (IOException e) {
				e.printStackTrace();
				JOptionPane.showMessageDialog(null, "Unexpected error occured when trying to save ELA result image. \n"
						+e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
			}
        }
    }
    
    /**
     * Method to save masked image based on ELA image difference to original image.
     * Copies the masked image from 'data' folder to the selected path.
     * 
     * @output JPEG-format image
     */
    void mSaveMaskedIMG() {
    	final JFileChooser fc = new JFileChooser();
        fc.setFileFilter(new FileNameExtensionFilter("JPG Image (JPG)", "jpg"));
        if(path != null) {
        	fc.setCurrentDirectory(new File(path));
        }
        fc.setSelectedFile(new File(FilenameUtils.removeExtension(inputfile.getName())+"_mask"));
        int result = fc.showSaveDialog(MenuBar);
        if (result == JFileChooser.APPROVE_OPTION) {
        	try {
				FileUtils.copyFile(new File("data/masked.jpg"), new File(fc.getSelectedFile()+".jpg"));
			} catch (IOException e) {
				JOptionPane.showMessageDialog(null, "Unexpected error occured when trying to save masked image. \n"
						+e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
			}
        }
    }
    
    /**
     * Method for saving thumbnail image extracted from EXIF metadata.
     * Copies the thumbnail image (if exists) from 'data' folder to the selected path.
     * 
     * @output JPG-format image
     */
    void mSaveThumbIMG() {
    	final JFileChooser fc = new JFileChooser();
        fc.setFileFilter(new FileNameExtensionFilter("JPG Image (JPG)", "jpg"));
        if(path != null) {
        	fc.setCurrentDirectory(new File(path));
        }
        fc.setSelectedFile(new File(FilenameUtils.removeExtension(inputfile.getName())+"_thumbnail"));
        int result = fc.showSaveDialog(MenuBar);
        if (result == JFileChooser.APPROVE_OPTION) {
        	try {
				FileUtils.copyFile(new File("data/thumbnail.jpg"), new File(fc.getSelectedFile()+".jpg"));
			} catch (IOException e) {
				e.printStackTrace();
				JOptionPane.showMessageDialog(null, "Unexpected error occured when trying to save extracted thumbnail. \n"
						+e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
			}
        }
    }

    /**
     * Saves metadata information to an external Tab-separated values (TSV) file.
     * 
     * @output Tab-separated values (TSV) file
     */
    void mSaveMetadata() {
    	final JFileChooser fc = new JFileChooser();
        fc.setFileFilter(new FileNameExtensionFilter("Tab Separated Values (TSV)", "tsv"));
        if(path != null) {
        	fc.setCurrentDirectory(new File(path));
        }
        fc.setSelectedFile(new File(FilenameUtils.removeExtension(inputfile.getName())+"_metadata"));
        int result = fc.showSaveDialog(MenuBar);
        if (result == JFileChooser.APPROVE_OPTION) {
        	saveMetaTable(tMetadata, new File(fc.getSelectedFile()+".tsv"));
        }
    }
    
    /**
     * Method for writing a TSV-format file from JTable.
     * 
     * @param table	The JTable which content will be exported. 
     * @param file	The output file chosen.
     */
	void saveMetaTable(JTable table, File file){
	    try{
	        TableModel model = table.getModel();
	        FileWriter excel = new FileWriter(file);
	
	        for(int i = 0; i < model.getColumnCount(); i++){
	            excel.write(model.getColumnName(i) + "\t");
	        }
	
	        excel.write("\n");
	
	        for(int i=0; i< model.getRowCount(); i++) {
	            for(int j=0; j < model.getColumnCount(); j++) {
	            	if(model.getValueAt(i,j) == null) {
	            		excel.write(" \t");
	            	}else {
	            		excel.write(model.getValueAt(i,j).toString()+"\t");
	            	}
	            }
	            excel.write("\n");
	        }
	
	        excel.close();
	
	    }catch(IOException e){ System.out.println(e); }
	}

	/**
	 * Method for writing the metadata into JTable.
	 * Uses metadata-extractor library. 
	 * 
	 * @param metadata	Metadata of the image, taken from metadata-extractor library.
	 * @param tMetadata	JTable which will displays the metadata. 
	 * @param tmodel	Java table model which will contains the metadata.
	 * @throws ImageProcessingException
	 * @throws IOException
	 */
    void writeTable(Metadata metadata, JTable tMetadata, DefaultTableModel tmodel) throws ImageProcessingException, IOException {
    	tmodel = (DefaultTableModel) tMetadata.getModel();
    	tmodel.setRowCount(0);
    	TableRowSorter<TableModel> sorter = new TableRowSorter<TableModel>(tMetadata.getModel());
        tMetadata.setRowSorter(sorter);
        
        for (Directory directory : metadata.getDirectories()) {
            for (Tag tag : directory.getTags()) {
            	tmodel.addRow(new Object[]{directory.getName(), tag.getTagName(), tag.getDescription()});
            }
        }
        mntmSaveMetadata.setEnabled(true);
    }    
   
    /**
     * Method for initializing the application analysis.
     * Calculate and set most size-related field.
     */
    private void runStart() {
    	oriWidth = imgInput.getWidth();
    	oriHeight = imgInput.getHeight();
    	
        scaleWidth = imgInput.getWidth();        
        scaleHeight = imgInput.getHeight();
        double ratio = 0;
        
        if(scaleWidth > labWidth && scaleWidth > scaleHeight) {
        	ratio = ((double) labWidth) / ((double) scaleWidth);
        	scaleWidth = (int) (scaleWidth * ratio);
        	scaleHeight = (int) (scaleHeight * ratio);
        }
        if(scaleHeight > labHeight){
        	ratio = ((double) labHeight) / ((double) scaleHeight);
        	scaleWidth = (int) (scaleWidth * ratio);
        	scaleHeight = (int) (scaleHeight * ratio);
        }
    }
    
    /**
     * Method for scaling the input image to be displayed in the panel.
     * Follows aspect ratio of the original file, calculated in runStart().
     * 
     * @throws IOException
     * @throws ImageProcessingException
     */
    private void runInput() throws IOException, ImageProcessingException{  
        img = imgInput.getScaledInstance(scaleWidth, scaleHeight, Image.SCALE_SMOOTH);
        imgIco = new ImageIcon(img);
        labInput.setIcon(imgIco);
    }
    
    /**
     * Method for calculating and set all statistics for the input image.
     * Set the label values related to the statistics.
     */
    private void runInputStatistics() {
    	int[][][] original = ImageTools.RGBArray(imgInput);
    	
    	int sumMag = 0; 
    	int[] chanInMin = {255,255,255};
        int[] chanInMax = {0,0,0};
        long[] chanInAvg = {0, 0, 0};
        int[] magIn = {255, 0};
        float magInAvg = 0;
    	
    	for (int r = 0; r < oriHeight; r++) {
            for (int c = 0; c < oriWidth; c++) {                	
                for (int band = 0; band < 3; band++) {
                	int input = original[r][c][band];
                	
                    chanInMin[band] = (input < chanInMin[band]) ? input : chanInMin[band];
                    chanInMax[band] = (input > chanInMax[band]) ? input : chanInMax[band];
                    chanInAvg[band] = chanInAvg[band] + input; 
                }
                
                sumMag = original[r][c][0] + original[r][c][1] + original[r][c][2];
                magInAvg = magInAvg + sumMag;
                magIn[0] = (sumMag < magIn[0]) ? sumMag : magIn[0];
                magIn[1] = (sumMag > magIn[1]) ? sumMag : magIn[1];
            }
    	}
    	magInAvg = magInAvg / (oriHeight * oriWidth);
        chanInAvg[0] = chanInAvg[0] / (oriHeight * oriWidth);
        chanInAvg[1] = chanInAvg[1] / (oriHeight * oriWidth);
        chanInAvg[2] = chanInAvg[2] / (oriHeight * oriWidth);
        
    	Apps.setInputStats(chanInMin, chanInMax, magIn, chanInAvg, magInAvg);
    }
    
    /**
     * Method for re-compressing input image and displays the result in the panel.
     * Quality level affect the re-compressing quality.
     * Uses Java image generation method.
     * 
     * @throws IOException
     */
    private void runRecomp() throws IOException {
        imgRecomp = ImageELA.GetCompressedImage(imgInput, (float) qualityLevel / 100);
        img = imgRecomp.getScaledInstance(scaleWidth, scaleHeight, Image.SCALE_SMOOTH);
        imgIco = new ImageIcon(img);
        labComp.setIcon(imgIco);
        outputfile = new File("data/recompressed.jpg");
        ImageIO.write(imgRecomp, "jpg", outputfile);
        mntmSaveRecomp.setEnabled(true);
    }
    
    /**
     * Method for calculating and set all statistics for the re-compressed image.
     * Set the label values related to the statistics.
     */
    private void runRecompStatistics() {
    	int[][][] comp = ImageTools.RGBArray(imgRecomp);
    	
    	int sumMag = 0; 
    	int[] chanRecMin = {255,255,255};
     	int[] chanRecMax = {0,0,0};
     	long[] chanRecAvg = {0, 0, 0};
        int[] magRec = {255, 0};
        float magRecAvg = 0;
    	
    	for (int r = 0; r < oriHeight; r++) {
            for (int c = 0; c < oriWidth; c++) {                	
                for (int band = 0; band < 3; band++) {
			    	int compr = comp[r][c][band];
			    	
			    	chanRecMin[band] = (compr < chanRecMin[band]) ? compr : chanRecMin[band];
			        chanRecMax[band] = (compr > chanRecMax[band]) ? compr : chanRecMax[band];
			        chanRecAvg[band] = chanRecAvg[band] + compr; 
                }
                
                sumMag = comp[r][c][0] + comp[r][c][1] + comp[r][c][2];
		        magRecAvg = magRecAvg + sumMag;
		        magRec[0] = (sumMag < magRec[0]) ? sumMag : magRec[0];
		        magRec[1] = (sumMag > magRec[1]) ? sumMag : magRec[1];
            }
    	}
		magRecAvg = magRecAvg / (oriHeight * oriWidth);
	    chanRecAvg[0] = chanRecAvg[0] / (oriHeight * oriWidth);
	    chanRecAvg[1] = chanRecAvg[1] / (oriHeight * oriWidth);
	    chanRecAvg[2] = chanRecAvg[2] / (oriHeight * oriWidth);
    	Apps.setRecompStats(chanRecMin, chanRecMax, magRec, chanRecAvg, magRecAvg);
    }
    
    /**
     * Method for comparing the input and re-compressed image, 
     	* generate the ELA image with PNG format (to prevent inaccurate values caused by compression), 
     	* saves it to disk, and displays the result in the panel.
     * RGB-based color image.
     * Error scale can generate RGB channel values over 255.
     * Error scale affect the ELA result image.
     * 
     * Uses Java buffered image and setRGB method.
     	* Important note: Java setRGB >255 inconsistency.
		* @author Muhammad Fauzi Rahman
		* 
		* Error scaling in this application mostly generate RGB values more than 255.
		* The default Java setRGB methods (most probably) uses this formula if more than 255 is used.
		* 
		* Red = Red % 255 (on low scale, mostly), Red % ? (sometimes it is unknown what % is used to calculate)
		* Green = Green % 255 (on low scale, mostly), Red % ? (sometimes it is unknown what % is used to calculate)
		* Blue = Blue % 256 (Most probably consistent, didn't find any different values than 256)
		* 
		* To prevent inaccuracy when taking each channel values from the generated ELA image, sees workaround.
		* 
		* @test Random error scale between 1-100.
		* @java v1.8 (JDK 8) and v10 (JDK 10).
		* @cause Unknown, probably the method limitation (limit: 255).
		* @workaround Each channel values directly calculated with % 256 in ELA image generation (ImageELA.java:100).
     * @output PNG-format ELA image
     * @throws IOException
     */
    private void runELA() throws IOException {
         imgELA = ImageELA.GetDifferenceImage(imgInput, imgRecomp, errLevel);
         img = imgELA.getScaledInstance(scaleWidth, scaleHeight, Image.SCALE_SMOOTH);
         imgIco = new ImageIcon(img);
         labELA.setIcon(imgIco);
         outputfile = new File("data/ELA.jpg");
         ImageIO.write(imgELA, "jpg", outputfile);
         mntmSaveEla.setEnabled(true);
    }
    
    /**
     * Method for calculating and set all statistics related to ELA result image.
     * 
     * Re-read the ELA image from disk (because the scaling may give values over 255)
     * Set the value of labels related to statistics.
     * 
     * @throws IOException
     */
    private void runElaStatistics() throws IOException {
        imgELA = ImageIO.read(outputfile);
        int[][][] elaRGB = ImageTools.RGBArray(imgELA);
        
        int[] chanElaMin = {1000,1000,1000};
        int[] chanElaMax = {0,0,0};
        long[] chanElaAvg = {0, 0, 0};
        int[] magEla = {1000, 0};
        
        long magElaSum = 0; 
        float magElaAvg = 0;
                
        for (int r = 0; r < oriHeight; r++) {
            for (int c = 0; c < oriWidth; c++) {
           	 	for (int band = 0; band < 3; band++) {
           		 	int currChannel = elaRGB[r][c][band];
           		 	
           		 	chanElaMin[band] = (currChannel < chanElaMin[band]) ? currChannel : chanElaMin[band];
                    chanElaMax[band] = (currChannel > chanElaMax[band]) ? currChannel : chanElaMax[band];
           	 	}
           	 	
           	 	int sumMag = elaRGB[r][c][0] + elaRGB[r][c][1] + elaRGB[r][c][2];
           	 	chanElaAvg[0] = chanElaAvg[0] + elaRGB[r][c][0];
           	 	chanElaAvg[1] = chanElaAvg[1] + elaRGB[r][c][1];
           	 	chanElaAvg[2] = chanElaAvg[2] + elaRGB[r][c][2];
           	 	magElaSum = magElaSum + sumMag;
                magEla[0] = (sumMag < magEla[0]) ? sumMag : magEla[0];
                magEla[1] = (sumMag > magEla[1]) ? sumMag : magEla[1];
            }
        }
        
        magElaAvg = (float) magElaSum / (float)(oriHeight * oriWidth);
        chanElaAvg[0] = chanElaAvg[0] / (oriHeight * oriWidth);
        chanElaAvg[1] = chanElaAvg[1] / (oriHeight * oriWidth);
        chanElaAvg[2] = chanElaAvg[2] / (oriHeight * oriWidth);
        
        setElaStats(chanElaMin, chanElaMax, magEla, chanElaAvg, magElaAvg);
    }
     
    /**
     * Method for generating masked original image based from ELA result, displays the image, and saves the image to disk.
     * @output JPEG-format masked image.
     * @throws IOException
     */
    private void runMask() throws IOException {
    	imgMask = ImageMask.MaskImages(imgInput, imgELA, MASK_RGB, maskThreshold);
        img = imgMask.getScaledInstance(scaleWidth, scaleHeight, Image.SCALE_SMOOTH);
        imgIco = new ImageIcon(img);
        labMask.setIcon(imgIco);
        outputfile = new File("data/masked.jpg");
        ImageIO.write(imgMask, "jpg", outputfile);
        mntmSaveMaskedImage.setEnabled(true);
    }
    
    /**
     * Methods for displaying slider value in the related label.
     */
    public void updQVal() {
    	qualityLevel = sliderQuality.getValue();
    	sliderQuality.setToolTipText(String.valueOf(sliderQuality.getValue()));   	
    	labValQ.setText(String.valueOf(sliderQuality.getValue())+"%");
    }
    public void updErrVal() {
    	errLevel = sliderErrScale.getValue();
    	sliderErrScale.setToolTipText(String.valueOf(sliderErrScale.getValue()));   	
    	labValE.setText(String.valueOf(sliderErrScale.getValue()));
    }
    public void updTVal() {
    	maskThreshold = sliderThresh.getValue();
    	sliderThresh.setToolTipText(String.valueOf(sliderThresh.getValue()));   	
    	labValT.setText(String.valueOf(sliderThresh.getValue()));
    }
    
    /**
     * Method for applying ELA configurations and run the ELA task.
     * Based on error scale and quality level values.
     * @throws ImageProcessingException
     * @throws IOException
     */
    public void applyConfigELA() throws ImageProcessingException, IOException {
    	if(inputfile != null) {
    		loadingBar.setIndeterminate(true);
    		loadingBar.setString("Processing");
    		labELA.setIcon(null);
    		taskType = 1;
    		taskEla = new Task();
    		taskEla.execute();
    	}
    }
    
    /**
     * Method for applying the default ELA configurations and run the task.
     */
    public void defConfigELA() {
    	sliderQuality.setValue(95);
    	sliderErrScale.setValue(20);
    	loadingBar.setIndeterminate(true);
    	loadingBar.setString("Processing");
    	if(inputfile != null) {
    		loadingBar.setIndeterminate(true);
    		taskType = 1;
    		taskEla = new Task();
    		taskEla.execute();
    	}
    }
    
    /**
     * Method for applying the mask configurations and run the task.
     */
    public void applyMask() {
    	if(inputfile != null) {
    		loadingBar.setIndeterminate(true);
        	loadingBar.setString("Processing");
    		taskType = 2;
    		taskMask = new Task();
    		taskMask.execute();    		
    	}
    }
    
    /**
     * Method for applying the default mask configurations and run the task.
     */
    public void defMask() {
    	if(inputfile != null) {
    		loadingBar.setIndeterminate(true);
	    	sliderThresh.setValue(25);
	    	taskType = 2;
    		taskMask = new Task();
    		taskMask.execute();
    	}
    }
        
    /**
     * Method for formatting the file size up to MegaByte (MB).
     *  
     * @param bytes	The size numbers which will be formatted.
     * @return
     */
    public String formatSize(long bytes) {
        NumberFormat nf = NumberFormat.getNumberInstance(Locale.ITALY);
        
        nf.setMaximumFractionDigits(2);
        nf.setMinimumFractionDigits(0);
        String format = bytes + " Bytes";
        if (bytes / MEGA_BYTES > 0) {
            format = nf.format(bytes) + " Bytes (" + nf.format((double) bytes / MEGA_BYTES) + " MB)";
        } else if (bytes / KILO_BYTES > 0) {
            format = nf.format(bytes) + " Bytes (" + nf.format((double) bytes / KILO_BYTES) + " KB)";
        } else {
            format = nf.format(bytes) + " Bytes";
        }

        return format;
    }
    

    /**
     * Method for checking if thumbnail is exists inside the EXIF metadata.
     * @throws IOException 
     */
    public void chkThumb() throws IOException {
    	thumbExists = false;
    	    	
    	/*
    	 * 1: For JPEG EXIF thumbnail image.
    	 * 2: For multipage TIFF, takes the 2nd page (thumbnail image) as thumbnail
    	 */
    	if(metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class) != null &&
    			metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_THUMBNAIL_OFFSET) != null &&
    			metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_THUMBNAIL_LENGTH) != null &&
    			metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_THUMBNAIL_OFFSET) != 0 &&
    			metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_THUMBNAIL_LENGTH) != 0){
    		thumbExists = true;
    		thumbWidth = metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_X_RESOLUTION);
    		thumbHeight = metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_Y_RESOLUTION);
    		thumbLen = metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_THUMBNAIL_LENGTH);
    	}else if(metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class) != null &&
    			
    			metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_STRIP_OFFSETS) != null &&
    			metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_STRIP_BYTE_COUNTS) != null &&
    			metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_STRIP_OFFSETS) != 0 &&
    			metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_STRIP_BYTE_COUNTS) != 0){
    		thumbExists = true;
    		thumbWidth = metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_X_RESOLUTION);
    		thumbHeight = metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_Y_RESOLUTION);
    		thumbLen = metadata.getFirstDirectoryOfType(ExifThumbnailDirectory.class).getInteger(ExifThumbnailDirectory.TAG_STRIP_BYTE_COUNTS);
    		
    		ImageInputStream is = ImageIO.createImageInputStream(inputfile);
			Iterator<ImageReader> iterator = ImageIO.getImageReaders(is);
			
			//Reading the 2nd page image as thumbnail.
			ImageReader reader = (ImageReader) iterator.next();
			iterator = null;
			reader.setInput(is);
			imgThumb = reader.read(1);
			
			outputfile = new File("data/thumbnail.jpg");
	        ImageIO.write(imgThumb, "jpg", outputfile);
    	} 
    }
    
    /**
     * Method for scaling, and displays the thumbnail information on the apps.
     */
    public void setThumb() {
    	if(thumbExists == true) {
    		labThumbSmall.setText(null);
			labThumbBig.setText(null);
			
			int labThumbSmallHeight = labThumbSmall.getHeight();
			int labThumbSmallWidth = labThumbSmall.getHeight();
			
			int labThumbBigHeight = labThumbBig.getHeight();
			int labThumbBigWidth = labThumbBig.getWidth();
			
			try {
				imgThumb = ImageIO.read(new File("data/thumbnail.jpg"));
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			/**
			 * Small thumbnail
			 */
			double ratio = 0;
			int thumbScaleWidth = imgThumb.getWidth();
			int thumbScaleHeight = imgThumb.getHeight();
				        
	        if(thumbScaleWidth > labThumbSmallWidth && thumbScaleWidth > thumbScaleHeight) {
	        	ratio = ((double) labThumbSmallWidth) / ((double) thumbScaleWidth);
	        	thumbScaleWidth = (int) (thumbScaleWidth * ratio);
	        	thumbScaleHeight = (int) (thumbScaleHeight * ratio);
	        }
	        if(thumbScaleHeight > labThumbSmallHeight){
	        	ratio = ((double) labThumbSmallHeight) / ((double) thumbScaleHeight);
	        	thumbScaleWidth = (int) (thumbScaleWidth * ratio);
	        	thumbScaleHeight = (int) (thumbScaleHeight * ratio);
	        };
			
			img = imgThumb.getScaledInstance(thumbScaleWidth, thumbScaleHeight, Image.SCALE_SMOOTH);
			imgIco = new ImageIcon(img);
			labThumbSmall.setIcon(imgIco);

			/**
			 * Large thumbnail
			 */
			ratio = 1;
			thumbScaleWidth = imgThumb.getWidth();
			thumbScaleHeight = imgThumb.getHeight();
			
			if(thumbScaleWidth > labThumbBigWidth || thumbScaleHeight > labThumbBigHeight) {
				if(thumbScaleWidth > thumbScaleHeight) {
			    	ratio = ((double) labThumbBigWidth) / ((double) thumbScaleWidth);
			    }else if(thumbScaleHeight > labThumbBigHeight){
			    	ratio = ((double) labThumbBigHeight) / ((double) thumbScaleHeight);
			    }
				
			    thumbScaleWidth = (int) (thumbScaleWidth * ratio);
				thumbScaleHeight = (int) (thumbScaleHeight * ratio);
				System.out.println("IF BIGGER");
			}else{
				if(thumbScaleWidth > thumbScaleHeight) {
					ratio = ((double) labThumbBigWidth) / ((double) thumbScaleWidth);
				}else{
					ratio = ((double) labThumbBigHeight) / ((double) thumbScaleHeight);
				}
				
				thumbScaleWidth = (int) (thumbScaleWidth * ratio);
				thumbScaleHeight = (int) (thumbScaleHeight * ratio);
				System.out.println(ratio);
				if(thumbScaleWidth > labThumbBigWidth) {
					ratio = (double) labThumbBigWidth / (double) thumbScaleWidth; 
					thumbScaleWidth = (int) (thumbScaleWidth * ratio);
					thumbScaleHeight = (int) (thumbScaleHeight * ratio);
					System.out.println("1"+ratio);
				}

				if(thumbScaleHeight > labThumbBigHeight) {
					ratio = (double) labThumbBigHeight / (double) thumbScaleHeight; 
					thumbScaleWidth = (int) (thumbScaleWidth * ratio);
					thumbScaleHeight = (int) (thumbScaleHeight * ratio);
					System.out.println("2"+ratio);
				}
				
				System.out.println("IF SMALLER");
			}
			
			img = imgThumb.getScaledInstance(thumbScaleWidth, thumbScaleHeight, Image.SCALE_SMOOTH);
			imgIco = new ImageIcon(img);
			labThumbBig.setIcon(imgIco);
    	}else {
    		labThumbBig.setIcon(null);
    		labThumbSmall.setIcon(null);
    		labThumbSmall.setText("Thumbnail metadata is not exists.");
    		labThumbBig.setText("Thumbnail comparison is not available.");
    	}
    }
    
    /**
     * Method for clearing the 'data' folder which stored all processed images except input.
     */
    public void clearTemp(){
    	if(outputfile != null) {
    		File dir = outputfile.getParentFile();
        	for(File file: dir.listFiles()) 
        	    if (!file.isDirectory()) 
        	        file.delete();
    	}
    }

    /**
     * Methods for displays input image statistics on related labels.
     * @param minparams	Arrays of minimum values of input image's RGB channels.
     * @param maxparams	Arrays of maximum values of input image's RGB channels.
     * @param mag		Arrays of minimum and maximum magnitude values of the input image.
     * @param chanInAvg	Arrays of average values of input image's RGB channels.
     * @param avgmag	The average magnitude values of the input image .
     */
    public static void setInputStats(int[] minparams, int[] maxparams, int[] mag, long[] chanInAvg, float avgmag) {
    	labInMinR.setText(minparams[0]+"");
    	labInMinG.setText(minparams[1]+"");
    	labInMinB.setText(minparams[2]+"");
    	
    	labInMaxR.setText(maxparams[0]+"");
    	labInMaxG.setText(maxparams[1]+"");
    	labInMaxB.setText(maxparams[2]+"");
    	
    	labInMinMag.setText(mag[0]+"");
    	labInMaxMag.setText(mag[1]+"");
    	
    	labInAvgR.setText(chanInAvg[0]+"");
    	labInAvgG.setText(chanInAvg[1]+"");
    	labInAvgB.setText(chanInAvg[2]+"");
    	
    	labInAvgMag.setText(avgmag+"");
    }
    
    /**
     * Methods for displays re-compressed image statistics on related labels.
     * @param minparams		Arrays of minimum values of re-compressed image's RGB channels.
     * @param maxparams		Arrays of maximum values of re-compressed image's RGB channels.
     * @param mag			Arrays of minimum and maximum magnitude values of the re-compressed image.
     * @param chanRecAvg	Arrays of average values of re-compressed image's RGB channels.
     * @param avgmag		The average magnitude values of the re-compressed image.
     */
    public static void setRecompStats(int[] minparams, int[] maxparams, int[] mag, long[] chanRecAvg, float avgmag) {
    	labRecMinR.setText(minparams[0]+"");
    	labRecMinG.setText(minparams[1]+"");
    	labRecMinB.setText(minparams[2]+"");
    	
    	labRecMaxR.setText(maxparams[0]+"");
    	labRecMaxG.setText(maxparams[1]+"");
    	labRecMaxB.setText(maxparams[2]+"");
    	
    	labRecMinMag.setText(mag[0]+"");
    	labRecMaxMag.setText(mag[1]+"");
    	
    	labRecAvgR.setText(chanRecAvg[0]+"");
    	labRecAvgG.setText(chanRecAvg[1]+"");
    	labRecAvgB.setText(chanRecAvg[2]+"");
    	
    	labRecAvgMag.setText(avgmag+"");
    }
    
    /**
     * Methods for displays ELA image statistics on related labels.
     * @param minparams		Arrays of minimum values of ELA image's RGB channels.
     * @param maxparams		Arrays of maximum values of ELA image's RGB channels.
     * @param mag			Arrays of minimum and maximum magnitude values of the ELA image.
     * @param chanElaAvg	Arrays of average values of ELA image's RGB channels.
     * @param avgmag		The average magnitude values of the ELA image .
     */
    public static void setElaStats(int[] minparams, int[] maxparams, int[] mag, long[] chanElaAvg, float avgmag) {
    	labElaMinR.setText(minparams[0]+"");
    	labElaMinG.setText(minparams[1]+"");
    	labElaMinB.setText(minparams[2]+"");
    	
    	labElaMaxR.setText(maxparams[0]+"");
    	labElaMaxG.setText(maxparams[1]+"");
    	labElaMaxB.setText(maxparams[2]+"");
    	labElaMaxR.setToolTipText(maxparams[0]+"");
    	labElaMaxG.setToolTipText(maxparams[1]+"");
    	labElaMaxB.setToolTipText(maxparams[2]+"");
    	
    	labElaMinMag.setText(mag[0]+"");
    	labElaMaxMag.setText(mag[1]+"");
    	labElaMaxMag.setToolTipText(mag[1]+"");
    	
    	labElaAvgR.setText(chanElaAvg[0]+"");
    	labElaAvgG.setText(chanElaAvg[1]+"");
    	labElaAvgB.setText(chanElaAvg[2]+"");
    	
    	labElaAvgMag.setText(avgmag+"");
    }
 
    /**
     * Method for changing the mask color based on mask color configuration.
     */
    public void maskColorChange() {
    	Object item = comboMaskCol.getSelectedItem();
    	MASK_RGB = ((ComboItem)item).getValue();
    }
    
    /**
     * Method for (suggesting) Java to call garbage collector.
     */
    public void callGC() {
    	System.gc();
    }
    
    /**
     * Subclass for the background image processes.
     * @author mfrfa
     *
     */
    class Task extends SwingWorker<Void, String> {
        /*
         * Main task. Executed in background thread.
         */
        @Override
        public Void doInBackground() throws ImageProcessingException, IOException {
        	if(taskType == 1) {
        		/**
        		 * Disables all task creation triggers.
        		 */
        		mOpen.setEnabled(false);
        		btnConfMask.setEnabled(false);
        		btnDefMask.setEnabled(false);
        		btnConfEla.setEnabled(false);
        		btnDefEla.setEnabled(false);
        		
        		/**
        		 * Checks if the task is running from the open image method.
        		 */
        		if(isOpening == true) {
        			runStart();
            		
            		setTitle("Digital Image Forensics Tools (Processing Input Image)");
            		loadingBar.setString("Processing Input Image");
            		runInput();
            		loadingBar.setString("Processing Input Image Statistics");
            		runInputStatistics();
            		
            		isOpening = false;
        		}        		
        		
        		setTitle("Digital Image Forensics Tools (Status: Rebuilding Image @ "+qualityLevel+"% Quality Level...)");
        		loadingBar.setString("Building Recompressed Image");
        		runRecomp();
        		loadingBar.setString("Processing Recompressed Image Statistics");
        		runRecompStatistics();
        		
        		setTitle("Digital Image Forensics Tools (Status: Processing Error Level Analysis @ "+errLevel+" Error Scale...)");
        		loadingBar.setString("Processing ELA Image");
        		runELA();
        		loadingBar.setString("Processing ELA Result Statistics");
        		runElaStatistics();
        		
        		setTitle("Digital Image Forensics Tools (Status: Processing Image Mask...)");
        		sliderThresh.setValue((int) Float.parseFloat(labElaAvgMag.getText()));
        		loadingBar.setString("Processing Image Mask");
        		runMask();
        	}else if (taskType == 2){
        		setTitle("Digital Image Forensics Tools (Status: Processing Image Mask...)");
        		loadingBar.setString("Processing Image Mask");
        		runMask();
        	}
            return null;
        }
        
        /*
         * Executed in event dispatching thread
         */
        
        @Override
        public void done() {
        	/**
        	 * Enables all button and open menu.
        	 */
        	mOpen.setEnabled(true);
    		btnConfMask.setEnabled(true);
    		btnDefMask.setEnabled(true);
    		btnConfEla.setEnabled(true);
    		btnDefEla.setEnabled(true);
    		
    		/**
    		 * Change related UI components.
    		 */
        	loadingBar.setIndeterminate(false);
        	loadingBar.setValue(100);
        	loadingBar.setString("Completed");
            taskType = 0;
            callGC();
            setTitle("Digital Image Forensics Tools (Completed: "+inputfile.getName()+")");
        }
    }
}